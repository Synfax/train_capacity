rect_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xmin = c(7, 16),
xmax = c(10, 19),
ymin = -1000,
ymax = 1000,
fill = c("morning", "evening")
)
mean_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),
y = c(morning_to_flinders, evening_away_from_flinders),
xmin = c(7, 16),
xmax = c(10, 19),
fill = c("morning", "evening")
)
sph_plot <- ggplot() +
geom_rect(data = rect_data,
mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
alpha = 0.1) +
facet_grid(rows = vars(Direction)) +
geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
geom_point(data = for_select_station, mapping = aes(x = hour_of_day, y = sph, group = 1)) +
scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
labs(title = "Service Frequency by time of day", fill = " Peak Period") +
theme_bw(base_size = 13) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(legend.position = "bottom") +
xlab('Hour of day') +
ylab('Services per hour') +
coord_cartesian(ylim = c(0, max(for_select_station$sph) + 1 ))
interactive_sph = ggplotly(sph_plot, height = 550)
interactive_sph = layout(interactive_sph, height = "550", autosize = T, legend = list(orientation = "v",   # horizontal legend
yanchor = "middle",
x = 0.05,
y = 0.85,
bordercolor = "black",    # Border color of the legend
borderwidth = 1
))
div(class = "plot", interactive_sph)
#interactive_sph
#| echo: false
station_lines = readRDS('../r_objects/stations_with_lines.Rdata') %>%
filter(Station_Name == station) %>%
pull(lines) %>%
unlist() %>%
as.vector()
station_targets = readRDS('../r_objects/target_stations.Rdata') %>%
filter(Station_Name == station) %>%
pull(targets) %>%
unlist() %>%
as.vector() %>%
first()
#| echo: false
to_plot <- hourly_factors %>%
ungroup() %>%
as.data.frame() %>%
filter(Station_Name == station_targets, Day_Type == 'Normal Weekday') %>%
filter(Line_Name %in% station_lines) %>%
mutate(hour_of_day = as.numeric(hour_of_day)) %>%
group_by(hour_of_day, Direction) %>%
summarise(avg_patronage = mean(avg_patronage))
morning_to_flinders = to_plot %>%
filter(Direction == 'Towards Flinders',
as.numeric(hour_of_day) %in% peak_morning) %>%
pull(avg_patronage) %>% mean() %>% round(., 2)
evening_away_from_flinders = to_plot %>%
filter(Direction == 'Away from Flinders',
as.numeric(hour_of_day) %in% peak_evening) %>%
pull(avg_patronage) %>% mean() %>% round(., 2)
final_patronage_score = mean(c(morning_to_flinders, evening_away_from_flinders)) %>% round(., 2)
rect_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xmin = c(7, 16),
xmax = c(10, 19),
ymin = -100,
ymax = 1000,
fill = c("morning", "evening")
)
mean_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),
y = c(morning_to_flinders, evening_away_from_flinders),
xmin = c(7, 16),
xmax = c(10, 19),
fill = c("morning", "evening")
)
patronage_plot <- ggplot() +
geom_rect(data = rect_data,
mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
alpha = 0.1) +
facet_grid(rows = vars(Direction)) +
geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
geom_point(data = to_plot, mapping = aes(x = hour_of_day, y = avg_patronage, group = 1)) +
scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
labs(title = "Average patronage by time of day", fill = " Peak Period") +
theme_bw(base_size = 13) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
xlab('Hour of day') +
ylab('Patronage per train') +
coord_cartesian(ylim = c(0, max(to_plot$avg_patronage) + 50))
interactive_patronage = ggplotly(patronage_plot, height = 550)
interactive_patronage = layout(interactive_patronage, autosize = T, height = '550', legend = list(orientation = "v",   # horizontal legend
yanchor = "middle",
x = 0.05,
y = 0.85,
bordercolor = "black",    # Border color of the legend
borderwidth = 1
))
div(class = 'plot', interactive_patronage)
#| echo: false
# grz_nrz = near_properties %>%
#     filter(type_short %in% c('Neighbourhood residential', 'General residential')) %>%
#     filter(heritage == F)
grz_nrz = near_properties %>%
mutate(isNRZGRZ = case_when((zone_short %in% c('Neighbourhood residential', 'General residential', 'Residential growth') & !heritage) ~ T, .default =  F ) ) %>%
mutate(colour = ifelse(isNRZGRZ, 'orange' ,'black'))
bounds <- c(min(grz_nrz$lon, na.rm = T), min(grz_nrz$lat, na.rm = T),
max(grz_nrz$lon, na.rm = T), max(grz_nrz$lat, na.rm = T))
#fix panes
leaflet(grz_nrz) %>%
fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
addMapPane("labels", zIndex = 430) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
addPolygons(fillColor = ~colour, color = NA, weight = 0, fillOpacity = 0.7, options = pathOptions(pane = "polygons")) %>%
addLegend(position = 'bottomleft', colors = c('orange','black'), labels = c('Suitable lot for upzoning','Unsuitable lot'), title = "Lot Suitability")
n_suitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(isNRZGRZ) %>%
pull(n)
n_unsuitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(!isNRZGRZ) %>%
pull(n)
by_validity <- grz_nrz %>%
group_by(isNRZGRZ) %>%
summarise(total_area = sum(st_area(geom))) %>%
st_drop_geometry()
area_ratio = ( ( by_validity %>% filter(isNRZGRZ) %>% pull(total_area) ) / sum(by_validity$total_area) %>% unname() %>% as.vector() ) %>% round(.,2)
#| echo: false
by_zone_heritage <- near_properties %>%
st_drop_geometry() %>%
count(heritage, zone_short) %>%
dplyr::relocate(zone_short, .before = heritage) %>%
arrange(zone_short)
# by_zone_heritage %>%
#   mutate(heritage = ifelse(heritage, 'Yes','No')) %>%
#   reactable(
#     theme = sandstone(),
#     pagination = F,
#     columns = list(
#       zone_short = colDef(name = "Zone"),
#       heritage = colDef(name = "Heritage protected"),
#       n = colDef(name = "Number of lots")
#     )
#   )
by_zone_heritage %>%
group_by(zone_short) %>%
summarise(n_total = sum(n), percent = n[heritage] / n_total, n_heritage = n[heritage], n_not_heritage = n[!heritage]) %>%
mutate(percent = round(percent, 2)) %>%
relocate(n_total, .after = n_not_heritage) %>%
reactable(
theme = sandstone(),
pagination = F,
columns = list(
zone_short = colDef(name = "Zone"),
percent = colDef(name = "% Heritage"),
n_heritage = colDef(name = "# Heritage Lots"),
n_not_heritage = colDef(name = "# Non Heritage Lots"),
n_total = colDef(name = "Total")
)
)
#| echo: false
bus_stops = read_sf('../shapefiles/ptv/PTV_METRO_BUS_STOP.shp')
tram_stops = read_sf('../shapefiles/ptv/PTV_METRO_TRAM_STOP.shp')
tram_routes = read_sf('../shapefiles/Order_JRGGG7/ll_gda2020/esrishape/whole_of_dataset/victoria/PTV/PTV_METRO_TRAM_ROUTE.shp')
bus_routes = read_sf('../shapefiles/Order_JRGGG7/ll_gda2020/esrishape/whole_of_dataset/victoria/PTV/PTV_METRO_BUS_ROUTE.SHP')
bus_frequencies = readRDS(paste0('../r_objects/bus_stop_frequencies.Rdata')) %>%
rename(STOP_ID = "stop_id") %>%
mutate(STOP_ID = as.character(STOP_ID)) %>%
select(peak_type, n, STOP_ID) %>%
group_by(STOP_ID) %>%
summarise(avg_sph = mean(n))
tram_frequencies = readRDS(paste0('../r_objects/tram_stop_frequencies.Rdata')) %>%
rename(STOP_ID = "stop_id") %>%
mutate(STOP_ID = as.character(STOP_ID)) %>%
select(peak_type, n, STOP_ID) %>%
group_by(STOP_ID) %>%
summarise(avg_sph = mean(n))
locations = readRDS(paste0('../r_objects/locations.Rdata'))
station_location = locations %>%
filter(Station_Name == station) %>%
st_as_sf(coords = c('lng','lat'), crs = 'wgs84')
buffer = st_buffer(station_location, dist = radius) %>%
st_transform(crs = 7844)
near_bus_vector <- st_within(bus_stops, buffer, sparse = F)
bus_stops_near_station = bus_stops %>%
filter(near_bus_vector)
bus_routes_near_station = bus_routes %>%
filter(ROUTESHTNM %in% bus_stops_near_station$ROUTEUSSP) %>%
st_intersection(buffer)
near_tram_vector <- st_within(tram_stops, buffer, sparse = F)
tram_stops_near_station = tram_stops %>%
filter(near_tram_vector)
tram_routes_near_station = tram_routes %>%
filter(ROUTESHTNM %in% tram_stops_near_station$ROUTEUSSP) %>%
st_intersection(buffer)
tram_route_list <- tram_routes_near_station %>%
st_drop_geometry() %>%
pull(ROUTESHTNM) %>% unique()
bus_route_list <- bus_routes_near_station %>%
st_drop_geometry() %>%
pull(ROUTESHTNM) %>% unique()
leaflet() %>%
fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
addMapPane("labels", zIndex = 430) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
addCircleMarkers(data = tram_stops_near_station, color = "black", radius = 3, fillColor = "#78BE20", fillOpacity = 1, options = pathOptions(pane = 'polygons'), stroke = 0.5, weight = 1, opacity = 1) %>%
addCircleMarkers(data = bus_stops_near_station, fillOpacity = 1, radius = 3, fillColor = "#FF8200", color = "black", stroke = 0.5, options = pathOptions(pane = 'polygons'), weight = 1, opacity = 1) %>%
addPolylines(data = bus_routes_near_station, color = "#FF8200", options = pathOptions(pane = 'polygons'), fillOpacity = 0.7) %>%
addPolylines(data = tram_routes_near_station, color = "#78BE20", options = pathOptions(pane = 'polygons'), fillOpacity = 0.7) %>%
addPolygons(data = buffer, color = 'black', fillColor = 'grey', fillOpacity = 0.3, options = pathOptions(pane = 'polygons'))
bus_f_df <- bus_stops_near_station %>%
left_join(bus_frequencies, by = 'STOP_ID') %>%
group_by(ROUTEUSSP) %>%
summarise(avg_sph = mean(avg_sph, na.rm=T)) %>%
filter(!str_detect(ROUTEUSSP, ',')) %>%
st_drop_geometry() %>%
mutate(mode = 'bus')
tram_f_df <- tram_stops_near_station %>%
left_join(tram_frequencies, by = 'STOP_ID')  %>%
group_by(ROUTEUSSP) %>%
summarise(avg_sph = mean(avg_sph, na.rm=T)) %>%
filter(!str_detect(ROUTEUSSP, ',')) %>%
st_drop_geometry() %>%
mutate(mode = 'tram')
# tram_f_df <- data.frame( sph = tram_stops_near_station %>%
#   left_join(tram_frequencies, by = 'STOP_ID') %>%
#   pull(avg_sph), mode = 'Tram')
#
# bus_f_df <- data.frame(sph=bus_stops_near_station %>%
#   left_join(bus_frequencies, by = 'STOP_ID') %>%
#   pull(avg_sph), mode = 'Bus')
#| echo: false
merged_f_df = rbind.data.frame(tram_f_df, bus_f_df) %>%
filter(!is.na(avg_sph)) %>%
arrange(avg_sph)
merged_f_df %>%
mutate(weight = case_when(mode == "bus" ~ 1, mode == "tram" ~ 2)) %>%
mutate(weighted = weight*avg_sph) %>%
pull(weighted) %>%
sum(na.rm=T)
merged_f_df %>%
mutate(mode = stringr::str_to_title(mode) ) %>%
mutate(avg_sph = round(avg_sph, 2)) %>%
reactable(theme=sandstone(),
defaultSorted = 'avg_sph',
defaultSortOrder = 'desc',
columns =
list(ROUTEUSSP = colDef(name = "Route"),
avg_sph = colDef(name = "Service Frequency"),
mode = colDef(name = "Mode")))
library(devtools)
#devtools::install_github("walkerke/mapgl")
library(mapgl)
library(sf)
library(tidyverse)
library(data.table)
library(leaflet)
library(htmltools)
library(quarto)
library(dtplyr)
library(janitor)
library(arrow)
library(stringr)
library(DescTools)
library(mapview)
library(geosphere)
library(chron)
source('r/helpers.r')
source('r/constants.r')
source('r/main_functions.r')
# check directories
# if(!dir.exists('r_objects') ) {
#   dir.create('r_objects')
# }
#
# if(!dir.exists('data') ) {
#   dir.create('data')
# }
# run things for the quarto pages
patronage_data = load_and_clean_patronage_data()
hourly_factors = generate_hourly_information()
service_frequences = generate_service_frequency_information()
generate_station_location_info()
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
pull() %>%
unique()
library(quarto)
library(fs)
library(tidyverse)
# Render a report for each station
for (station in stations) {
print(station)
# Create a safe filename
safe_name <- gsub("[^a-zA-Z0-9]", "_", station)
# Set the output directory for this station
output_dir <- file.path("stations", safe_name)
dir.create(output_dir, recursive = T, showWarnings = FALSE)
# Render the report
quarto_render(
input = "quarto/run_for_station.qmd",
output_file = paste0(safe_name, ".html"),
execute_params = list(station = station),
output_format = "html",
quarto_args = c("--output-dir", output_dir)
)
fs::file_move(
path = file.path(output_dir, paste0(safe_name, ".html")),
new_path = file.path(output_dir, "quarto/", paste0(safe_name, ".html"))
)
}
library(tidyverse)
library(sf)
library(leaflet)
library(shiny)
library(htmlwidgets)
library(reactablefmtr)
locations <- readRDS('../r_objects/locations.Rdata')
transformed_scores <- readRDS('../r_objects/transformed_scores.Rdata') %>%
as.data.frame() %>%
slice_head(n = 10) %>%
mutate(across(where(is.numeric), .fns = function(x) round(x, 2) )) %>%
mutate(rank = row_number())
san_station <- function(x) {
return( str_replace(x, ' ', '_') )
}
translations = c(
'grz_nrz_pc' = 'Zoning suitability',
'capacity_delta' = 'Potential new homes',
'average_peak_service_freq' = 'Train frequency',
'average_peak_service_cap' = 'Available train capacity',
'walkability_score' = 'Local services',
'distance' = 'Distance to CBD',
'n_bus_tram' = 'Other transport infrastructure'
)
printScores <- function(r) {
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
text_position = 'above',
fill_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
) %>%
return()
}
printScores(1)
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
text_position = 'outside-base',
fill_color = 'white',
text_color = 'white'
background = 'opaque',
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
text_position = 'outside-base',
fill_color = 'white',
text_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
) %>%
return()
printScores <- function(r) {
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
text_position = 'outside-base',
fill_color = 'white',
text_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
) %>%
return()
}
printScores(1)
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
force_outside = c(0,0.2)),
fill_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
printScores <- function(r) {
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
force_outside = c(0,0.2)),
fill_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
) %>%
printScores(1)
printScores <- function(r) {
transformed_scores %>%
filter(rank == r) %>%
pivot_longer(-station) %>%
select(-station) %>%
filter(!(name %in% c('score','rank'))) %>%
mutate(name = translations[name]) %>%
reactable(theme = cyborg(),
class = "pageinforeactable",
columns = list(
'name' = colDef(name = 'Metric'),
'value' = colDef(name = "Score",
cell = data_bars(.,
force_outside = c(0,0.2),
fill_color = 'white',
background = 'opaque',
fill_opacity = 1,
bar_height = 24,
bold_text = T))
)
) %>%
return()
}
printScores(1)
