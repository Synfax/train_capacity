Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xmin = c(7, 16),
xmax = c(10, 19),
ymin = -100,
ymax = 1000,
fill = c("morning", "evening")
)
mean_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),
y = c(morning_to_flinders, evening_away_from_flinders),
xmin = c(7, 16),
xmax = c(10, 19),
fill = c("morning", "evening")
)
patronage_plot <- ggplot() +
geom_rect(data = rect_data,
mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
alpha = 0.1) +
facet_grid(rows = vars(Direction)) +
geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
geom_point(data = to_plot, mapping = aes(x = hour_of_day, y = avg_patronage, group = 1)) +
scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
labs(title = "Average patronage by time of day", fill = " Peak Period") +
theme_bw(base_size = 13) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
xlab('Hour of day') +
ylab('Patronage') +
coord_cartesian(ylim = c(0, max(to_plot$avg_patronage) + 50))
interactive_patronage = ggplotly(patronage_plot, height = 550)
interactive_patronage = layout(interactive_patronage, autosize = T, height = '550', legend = list(orientation = "v",   # horizontal legend
yanchor = "middle",
x = 0.05,
y = 0.85,
bordercolor = "black",    # Border color of the legend
borderwidth = 1
))
div(class = 'plot', interactive_patronage)
#| echo: false
# grz_nrz = near_properties %>%
#     filter(type_short %in% c('Neighbourhood residential', 'General residential')) %>%
#     filter(heritage == F)
grz_nrz = near_properties %>%
mutate(isNRZGRZ = case_when((zone_short %in% c('Neighbourhood residential', 'General residential') & !heritage) ~ T, .default =  F ) ) %>%
mutate(colour = ifelse(isNRZGRZ, 'orange' ,'black'))
bounds <- c(min(grz_nrz$lon, na.rm = T), min(grz_nrz$lat, na.rm = T),
max(grz_nrz$lon, na.rm = T), max(grz_nrz$lat, na.rm = T))
#fix panes
leaflet(grz_nrz) %>%
fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
addMapPane("labels", zIndex = 430) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
addPolygons(fillColor = ~colour, color = NA, weight = 0, fillOpacity = 0.7, options = pathOptions(pane = "polygons")) %>%
addLegend(position = 'bottomleft', colors = c('orange','black'), labels = c('Suitable lot for upzoning','Unsuitable lot'), title = "Lot Suitability")
n_suitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(isNRZGRZ) %>%
pull(n)
n_unsuitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(!isNRZGRZ) %>%
pull(n)
by_validity <- grz_nrz %>%
group_by(isNRZGRZ) %>%
summarise(total_area = sum(st_area(geom))) %>%
st_drop_geometry()
area_ratio = ( ( by_validity %>% filter(isNRZGRZ) %>% pull(total_area) ) / sum(by_validity$total_area) %>% unname() %>% as.vector() ) %>% round(.,2)
#| echo: false
station = params$station
peak_morning = 7:10
peak_evening = 16:19
library(knitr)
library(tidyverse)
library(sf)
library(leaflet)
devtools::install_github("walkerke/mapgl")
library(mapgl)
library(htmltools)
library(htmlwidgets)
library(reactablefmtr)
library(plotly)
source('../r/station_functions.R')
near_properties = get_near_properties(station, fromQuarto = T)
yimby_colours <- list(
hero = "#10461B",
body = "#000000",
background  = "#FDFFEE",
green_base  = "#10461B",
blue_base   = "#283696",
red_base    = "#BA1B21",
yellow_base = "#F6AE00",
green_palette  = c("#10461B", "#2C6F3A", "#579A64", "#8FC49A", "#D6EFDB"),
blue_palette   = c("#1A235F", "#283696", "#9EA7E2", "#D0D6FF", "#E8ECFF"),
red_palette    = c("#D92127", "#BA1B21", "#8E3437", "#C6A2A3", "#E3BABB"),
yellow_palette = c("#F6AE00", "#DE9B00", "#C79E3E", "#F2DCA5", "#FFF7E3")
)
specified_colors <- c("Already developed"                       = "#989898",
"Housing not permitted"                   = "#b1b1b1",
"Civic use makes development less likely" = "#cacaca",
"Low density residential"                 = yimby_colours$blue_palette[5],
"2 storeys (NRZ)"                         = yimby_colours$blue_palette[4],
"3 storeys (GRZ)"                         = yimby_colours$blue_palette[3],
"4 storeys (RGZ)"                         = yimby_colours$blue_palette[2],
"4+ storeys (Mixed use zones)"            = yimby_colours$blue_palette[1],
"6 storeys (Missing middle)"              = yimby_colours$green_palette[3]
)
hourly_factors = readRDS('../r_objects/hourly_factors.Rdata') %>%
as.data.frame()
#| echo: false
translations = c(
'grz_nrz_pc' = 'Zoning suitability (% residential and not heritage)',
'capacity_delta' = 'Potential new homes in broad 1000m upzoning',
'average_peak_service_freq' = 'Train frequency in peak (services per hour)',
'average_peak_service_cap' = 'Average train patronage in peak',
'walkability_score' = 'Number of local services within 500m walk',
'distance' = 'Distance to CBD (km)',
'n_bus_tram' = 'Number of bus and tram stops'
)
rankings = readRDS('../r_objects/station_rankings.Rdata') %>%
rename(Station_Name = "station") %>%
filter(Station_Name == station) %>%
pivot_longer(-Station_Name) %>%
select(-Station_Name) %>%
mutate(value = round(value, 2))
transformed_rankings = readRDS('../r_objects/transformed_scores.Rdata') %>%
rename(Station_Name = "station") %>%
filter(Station_Name == station) %>%
pivot_longer(-Station_Name) %>%
select(-Station_Name) %>%
mutate(value = round(value, 2)) %>%
filter(name != 'score')
rankings %>%
left_join(transformed_rankings, by = 'name') %>%
mutate(name = translations[name]) %>%
reactable(theme = sandstone(),
columns = list(
'name' = colDef(name = 'Metric'),
'value.x' = colDef(name = "Score"),
'value.y' = colDef(name = "Transformed Score")
)
)
#| echo: false
service_frequencies = readRDS('../r_objects/service_frequencies.Rdata')
for_select_station = service_frequencies %>%
filter(Station_Name == station) %>%
filter(Day_Type == 'Normal Weekday') %>%
mutate(hour_of_day = as.numeric(hour_of_day)) %>%
arrange(desc(Direction))
morning_to_flinders = for_select_station %>%
filter(Direction == 'Towards Flinders',
as.numeric(hour_of_day) %in% peak_morning) %>%
pull(sph) %>% mean() %>% round(., 2)
evening_away_from_flinders = for_select_station %>%
filter(Direction == 'Away from Flinders',
as.numeric(hour_of_day) %in% peak_evening) %>%
pull(sph) %>% mean() %>% round(., 2)
final_frequency_score = mean(c(morning_to_flinders, evening_away_from_flinders)) %>% round(., 2)
vlines <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xintercept = c( c(7, 16), c(10,19) ),
fill = c("morning", "evening")
)
rect_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xmin = c(7, 16),
xmax = c(10, 19),
ymin = -1000,
ymax = 1000,
fill = c("morning", "evening")
)
mean_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),
y = c(morning_to_flinders, evening_away_from_flinders),
xmin = c(7, 16),
xmax = c(10, 19),
fill = c("morning", "evening")
)
sph_plot <- ggplot() +
geom_rect(data = rect_data,
mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
alpha = 0.1) +
facet_grid(rows = vars(Direction)) +
geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
geom_point(data = for_select_station, mapping = aes(x = hour_of_day, y = sph, group = 1)) +
scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
labs(title = "Service Frequency by time of day", fill = " Peak Period") +
theme_bw(base_size = 13) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(legend.position = "bottom") +
xlab('Hour of day') +
ylab('Services per hour') +
coord_cartesian(ylim = c(0, max(for_select_station$sph) + 1 ))
interactive_sph = ggplotly(sph_plot, height = 550)
interactive_sph = layout(interactive_sph, height = "550", autosize = T, legend = list(orientation = "v",   # horizontal legend
yanchor = "middle",
x = 0.05,
y = 0.85,
bordercolor = "black",    # Border color of the legend
borderwidth = 1
))
div(class = "plot", interactive_sph)
#interactive_sph
#| echo: false
to_plot <- hourly_factors %>%
filter(Station_Name == station) %>%
filter(Day_Type == 'Normal Weekday') %>%
mutate(hour_of_day = as.numeric(hour_of_day)) %>%
group_by(hour_of_day, Direction) %>%
summarise(avg_patronage = mean(avg_patronage))
morning_to_flinders = to_plot %>%
filter(Direction == 'Towards Flinders',
as.numeric(hour_of_day) %in% peak_morning) %>%
pull(avg_patronage) %>% mean() %>% round(., 2)
evening_away_from_flinders = to_plot %>%
filter(Direction == 'Away from Flinders',
as.numeric(hour_of_day) %in% peak_evening) %>%
pull(avg_patronage) %>% mean() %>% round(., 2)
final_patronage_score = mean(c(morning_to_flinders, evening_away_from_flinders)) %>% round(., 2)
rect_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
xmin = c(7, 16),
xmax = c(10, 19),
ymin = -100,
ymax = 1000,
fill = c("morning", "evening")
)
mean_data <- data.frame(
Direction = c("Towards Flinders", "Away from Flinders"),
y = c(morning_to_flinders, evening_away_from_flinders),
xmin = c(7, 16),
xmax = c(10, 19),
fill = c("morning", "evening")
)
patronage_plot <- ggplot() +
geom_rect(data = rect_data,
mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
alpha = 0.1) +
facet_grid(rows = vars(Direction)) +
geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
geom_point(data = to_plot, mapping = aes(x = hour_of_day, y = avg_patronage, group = 1)) +
scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
labs(title = "Average patronage by time of day", fill = " Peak Period") +
theme_bw(base_size = 13) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
xlab('Hour of day') +
ylab('Patronage') +
coord_cartesian(ylim = c(0, max(to_plot$avg_patronage) + 50))
interactive_patronage = ggplotly(patronage_plot, height = 550)
interactive_patronage = layout(interactive_patronage, autosize = T, height = '550', legend = list(orientation = "v",   # horizontal legend
yanchor = "middle",
x = 0.05,
y = 0.85,
bordercolor = "black",    # Border color of the legend
borderwidth = 1
))
div(class = 'plot', interactive_patronage)
#| echo: false
# grz_nrz = near_properties %>%
#     filter(type_short %in% c('Neighbourhood residential', 'General residential')) %>%
#     filter(heritage == F)
grz_nrz = near_properties %>%
mutate(isNRZGRZ = case_when((zone_short %in% c('Neighbourhood residential', 'General residential') & !heritage) ~ T, .default =  F ) ) %>%
mutate(colour = ifelse(isNRZGRZ, 'orange' ,'black'))
bounds <- c(min(grz_nrz$lon, na.rm = T), min(grz_nrz$lat, na.rm = T),
max(grz_nrz$lon, na.rm = T), max(grz_nrz$lat, na.rm = T))
#fix panes
leaflet(grz_nrz) %>%
fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
addMapPane("labels", zIndex = 430) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
addPolygons(fillColor = ~colour, color = NA, weight = 0, fillOpacity = 0.7, options = pathOptions(pane = "polygons")) %>%
addLegend(position = 'bottomleft', colors = c('orange','black'), labels = c('Suitable lot for upzoning','Unsuitable lot'), title = "Lot Suitability")
n_suitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(isNRZGRZ) %>%
pull(n)
n_unsuitable = grz_nrz %>%
st_drop_geometry() %>%
count(isNRZGRZ) %>%
filter(!isNRZGRZ) %>%
pull(n)
by_validity <- grz_nrz %>%
group_by(isNRZGRZ) %>%
summarise(total_area = sum(st_area(geom))) %>%
st_drop_geometry()
area_ratio = ( ( by_validity %>% filter(isNRZGRZ) %>% pull(total_area) ) / sum(by_validity$total_area) %>% unname() %>% as.vector() ) %>% round(.,2)
#| echo: false
by_zone_heritage <- near_properties %>%
st_drop_geometry() %>%
count(heritage, zone_short) %>%
dplyr::relocate(zone_short, .before = heritage) %>%
arrange(zone_short)
# by_zone_heritage %>%
#   mutate(heritage = ifelse(heritage, 'Yes','No')) %>%
#   reactable(
#     theme = sandstone(),
#     pagination = F,
#     columns = list(
#       zone_short = colDef(name = "Zone"),
#       heritage = colDef(name = "Heritage protected"),
#       n = colDef(name = "Number of lots")
#     )
#   )
by_zone_heritage %>%
group_by(zone_short) %>%
summarise(n_total = sum(n), percent = n[heritage] / n_total, n_heritage = n[heritage], n_not_heritage = n[!heritage]) %>%
relocate(n_total, .after = n_not_heritage) %>%
reactable(
theme = sandstone(),
pagination = F,
columns = list(
zone_short = colDef(name = "Zone"),
heritage = colDef(name = "Heritage protected"),
percent = colDef(name = "% Heritage"),
n_heritage = colDef(name = "# Heritage Lots"),
n_not_heritage = colDef(name = "# Non Heritage Lots"),
n_total = colDef(name = "Total")
)
)
by_zone_heritage %>%
group_by(zone_short) %>%
summarise(n_total = sum(n), percent = n[heritage] / n_total, n_heritage = n[heritage], n_not_heritage = n[!heritage]) %>%
relocate(n_total, .after = n_not_heritage)
np %>% filter(zoning_permits_housing == 'Housing permitted') %>% count(zone_short)
library(tidyverse)
np %>% filter(zoning_permits_housing == 'Housing permitted') %>% count(zone_short)
library(devtools)
#devtools::install_github("walkerke/mapgl")
library(mapgl)
library(sf)
library(tidyverse)
library(data.table)
library(leaflet)
library(htmltools)
library(quarto)
library(dtplyr)
library(janitor)
library(arrow)
library(stringr)
library(DescTools)
library(mapview)
library(geosphere)
source('r/helpers.r')
source('r/main_functions.r')
np %>% filter(zoning_permits_housing == 'Housing permitted') %>% count(zone_short)
source("D:/train_capacity/r/station_functions.R", echo=TRUE)
source('r/station_functions.R')
if(!dir.exists('station_zoning_info')) {
dir.create('station_zoning_info')
}
if(!dir.exists('station_walkability_info')) {
dir.create('station_walkability_info')
}
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
distinct() %>%
slice_sample(prop = 1) %>%
unlist() %>%
as.vector()
#or
#set globals
walkability = read_parquet('data/walkability_by_node.parquet')%>%
janitor::clean_names() %>%
st_set_geometry('geometry') %>%
st_set_crs('wgs84')
dwelling_data = readRDS(paste0('data/final_dwelling_data.Rdata')) %>%
st_transform( 'wgs84')
station_rankings <- stations %>%
map(~ as_tibble(as.list(return_information(.x))), .progress = T) %>%
list_rbind() %>%
mutate(across(-station, as.numeric)) %>%
filter(!is.nan(walkability_score))
saveRDS(station_rankings, 'r_objects/station_rankings.Rdata')
source("D:/train_capacity/r/transform.R", echo=TRUE)
transformed_scores = transform_scores_xminxmax(station_rankings)
san_station = str_replace(station, ' ', '_')
library(devtools)
#devtools::install_github("walkerke/mapgl")
library(mapgl)
library(sf)
library(tidyverse)
library(data.table)
library(leaflet)
library(htmltools)
library(quarto)
library(dtplyr)
library(janitor)
library(arrow)
library(stringr)
library(DescTools)
library(mapview)
library(geosphere)
library(quarto)
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
distinct() %>%
slice_sample(prop = 1) %>%
unlist() %>%
as.vector()
# Render a report for each station
for (station in stations) {
# Create a safe filename
safe_name <- gsub("[^a-zA-Z0-9]", "_", station)
# Set the output directory for this station
output_dir <- file.path("stations", safe_name)
dir.create(output_dir, recursive = T, showWarnings = FALSE)
# Render the report
quarto_render(
input = "quarto/run_for_station.qmd",
output_file = paste0(safe_name, ".html"),
execute_params = list(station = station),
output_format = "html",
quarto_args = c("--output-dir", output_dir)
)
fs::file_move(
path = file.path(output_dir, paste0(safe_name, ".html")),
new_path = file.path(output_dir, "quarto/", paste0(safe_name, ".html"))
)
}
library(quarto)
library(tidyverse)
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
distinct() %>%
slice_sample(prop = 1) %>%
unlist() %>%
as.vector()
# Render a report for each station
for (station in stations) {
# Create a safe filename
safe_name <- gsub("[^a-zA-Z0-9]", "_", station)
# Set the output directory for this station
output_dir <- file.path("stations", safe_name)
dir.create(output_dir, recursive = T, showWarnings = FALSE)
# Render the report
quarto_render(
input = "quarto/run_for_station.qmd",
output_file = paste0(safe_name, ".html"),
execute_params = list(station = station),
output_format = "html",
quarto_args = c("--output-dir", output_dir)
)
fs::file_move(
path = file.path(output_dir, paste0(safe_name, ".html")),
new_path = file.path(output_dir, "quarto/", paste0(safe_name, ".html"))
)
}
library(quarto)
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
distinct() %>%
slice_sample(prop = 1) %>%
unlist() %>%
as.vector()
# Render a report for each station
for (station in stations) {
# Create a safe filename
safe_name <- gsub("[^a-zA-Z0-9]", "_", station)
# Set the output directory for this station
output_dir <- file.path("stations", safe_name)
dir.create(output_dir, recursive = T, showWarnings = FALSE)
# Render the report
quarto_render(
input = "quarto/run_for_station.qmd",
output_file = paste0(safe_name, ".html"),
execute_params = list(station = station),
output_format = "html",
quarto_args = c("--output-dir", output_dir)
)
}
rlang::last_trace()
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
distinct() %>%
pull()
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
pull() %>%
distinct()
# List of stations
stations = patronage_data %>%
filter(Mode == 'Metro') %>%
select(Station_Name) %>%
pull() %>%
unique()
