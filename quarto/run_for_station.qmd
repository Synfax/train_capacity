---
title: "Station Information"
author: "Paul S"
date: "6/6/24"
params: 
  station: "South Yarra"
format: 
  html: 
    theme: zephyr
    fig-width: 8
    fig-height: 6
    code-fold: false
    toc: true
    toc-depth: 4
    toc-location: left
    page-layout: full
---

```{r warning=FALSE,message=FALSE}
#| echo: false 
station = params$station

source('../r/constants.R')

library(knitr)
library(tidyverse)
library(sf)
library(leaflet)
devtools::install_github("walkerke/mapgl")
library(mapgl)
library(htmltools)
library(htmlwidgets)
library(reactablefmtr)
library(plotly)

source('../r/station_functions.R')

near_properties = get_near_properties(station, fromQuarto = T)

yimby_colours <- list(
  hero = "#10461B",
  body = "#000000",
  background  = "#FDFFEE",
  green_base  = "#10461B",
  blue_base   = "#283696",
  red_base    = "#BA1B21",
  yellow_base = "#F6AE00",
  green_palette  = c("#10461B", "#2C6F3A", "#579A64", "#8FC49A", "#D6EFDB"),
  blue_palette   = c("#1A235F", "#283696", "#9EA7E2", "#D0D6FF", "#E8ECFF"),
  red_palette    = c("#D92127", "#BA1B21", "#8E3437", "#C6A2A3", "#E3BABB"),
  yellow_palette = c("#F6AE00", "#DE9B00", "#C79E3E", "#F2DCA5", "#FFF7E3")
)

specified_colors <- c("Already developed"                       = "#989898",
                      "Housing not permitted"                   = "#b1b1b1",
                      "Civic use makes development less likely" = "#cacaca", 
                      "Low density residential"                 = yimby_colours$blue_palette[5],
                      "2 storeys (NRZ)"                         = yimby_colours$blue_palette[4],
                      "3 storeys (GRZ)"                         = yimby_colours$blue_palette[3],
                      "4 storeys (RGZ)"                         = yimby_colours$blue_palette[2],
                      "4+ storeys (Mixed use zones)"            = yimby_colours$blue_palette[1],
                      "6 storeys (Missing middle)"              = yimby_colours$green_palette[3]
)


hourly_factors = readRDS('../r_objects/hourly_factors.Rdata') %>%
  as.data.frame()

```

## Information & Overall Scores

This page includes information about the seven categories and why they should be considered as factors in priority upzoning:

-   Zoning suitability
-   Potential number of new homes
-   Train service frequency in peak
-   Train service passenger numbers in peak
-   Number of local services within a 500m walk
-   Distance to CBD
-   Existing transport infrastructure.

For `r station`, the scores are shown below in a summary table. The remainder of this page steps through each factor listed above in no particular order.

```{r warning=FALSE,message=FALSE}
#| echo: false 

translations = c(
  'grz_nrz_pc' = 'Zoning suitability (% residential and not heritage)',
  'capacity_delta' = 'Potential new homes in broad 1000m upzoning',
  'average_peak_service_freq' = 'Train frequency in peak (services per hour)',
  'average_peak_service_cap' = 'Average train patronage in peak',
  'walkability_score' = 'Number of local services within 500m walk',
  'distance' = 'Distance to CBD (km)',
  'n_bus_tram' = 'Number of bus and tram stops'
)

rankings = readRDS('../r_objects/station_rankings.Rdata') %>%
  rename(Station_Name = "station") %>%
  filter(Station_Name == station) %>%
  pivot_longer(-Station_Name) %>%
  select(-Station_Name) %>%
  mutate(value = round(value, 2)) 


transformed_rankings = readRDS('../r_objects/transformed_scores.Rdata') %>%
  rename(Station_Name = "station") %>%
  filter(Station_Name == station) %>%
  pivot_longer(-Station_Name) %>%
  select(-Station_Name) %>%
  mutate(value = round(value, 2)) %>%
  filter(name != 'score') 

total_score <- sum(transformed_rankings$value)

rankings %>%
  left_join(transformed_rankings, by = 'name') %>%
  mutate(name = translations[name]) %>%
reactable(theme = sandstone(),
            columns = list(
              'name' = colDef(name = 'Metric'),
              'value.x' = colDef(name = "Score"),
              'value.y' = colDef(name = "Transformed Score")
            )
            
            )

```

`r station` obtained a final score of `r total_score`, placing it. 

## Service Frequency

(why is frequency important?)

Service frequency is calculated as the mean number of services per hour in two time periods. The chart below shows:

-   Number of services between 7 and 10am towards Flinders Street, coloured blue.

-   Number of services between 4 and 7pm away from Flinders street, coloured green.

The chart is also split by direction of travel, which in Melbourne's radial network is either towards or away from Flinders street. 

The mean values of these two periods are shown as dashed lines, and the mean of those two numbers is the final score. 

```{r warning=FALSE,message=FALSE}
#| echo: false 


service_frequencies = readRDS('../r_objects/service_frequencies.Rdata')

for_select_station = service_frequencies %>%
  filter(Station_Name == station) %>%
  filter(Day_Type == 'Normal Weekday') %>%
  mutate(hour_of_day = as.numeric(hour_of_day)) %>%
  arrange(desc(Direction))

morning_to_flinders = for_select_station %>%
    filter(Direction == 'Towards Flinders',
           as.numeric(hour_of_day) %in% peak_morning) %>%
    pull(sph) %>% mean() %>% round(., 2)

evening_away_from_flinders = for_select_station %>%
    filter(Direction == 'Away from Flinders',
           as.numeric(hour_of_day) %in% peak_evening) %>%
    pull(sph) %>% mean() %>% round(., 2)

final_frequency_score = mean(c(morning_to_flinders, evening_away_from_flinders)) %>% round(., 2)

vlines <- data.frame(
  Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
  xintercept = c( c(7, 16), c(10,19) ),
  fill = c("morning", "evening")
)

rect_data <- data.frame(
  Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
  xmin = c(7, 16),
  xmax = c(10, 19),
  ymin = -1000,
  ymax = 1000,
  fill = c("morning", "evening")
)

mean_data <- data.frame(
  Direction = c("Towards Flinders", "Away from Flinders"),
  y = c(morning_to_flinders, evening_away_from_flinders),
  xmin = c(7, 16),
  xmax = c(10, 19),
  fill = c("morning", "evening")
)
  
sph_plot <- ggplot() +
  geom_rect(data = rect_data, 
            mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),  
            alpha = 0.1) + 
  facet_grid(rows = vars(Direction)) +
  geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
  geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
  geom_point(data = for_select_station, mapping = aes(x = hour_of_day, y = sph, group = 1)) +
  scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
  scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
  labs(title = "Service Frequency by time of day", fill = " Peak Period") +
  theme_bw(base_size = 13) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "bottom") + 
  xlab('Hour of day') + 
  ylab('Services per hour') + 
  coord_cartesian(ylim = c(0, max(for_select_station$sph) + 1 ))

interactive_sph = ggplotly(sph_plot, height = 550)
interactive_sph = layout(interactive_sph, height = "550", autosize = T, legend = list(orientation = "v",   # horizontal legend
                                         yanchor = "middle",
                                         x = 0.05,
                                         y = 0.85,
                                          bordercolor = "black",    # Border color of the legend
    borderwidth = 1
                                         ))

div(class = "plot", interactive_sph)
#interactive_sph
```

The morning average freqency is `r morning_to_flinders`, the average evening frequency is `r evening_away_from_flinders`, which forms a mean score of `r final_frequency_score`.

## Service Capacity

This metric aims to measure the amount of space available on trains passing through this station, as there is little point upzoning if there is no capacity to move people.

However, for stations in the middle of a train line, passengers will typically continue to board the train until the city. This means that it is not useful to only look at the patronage as trains pass through a given station as more passengers may board later.

Instead, it is best to look at the average number of passengers on trains at their last station before the CBD. This gives a better measure of how busy the line itself is overall.

Process for `r station`

1. Find the train lines that serve `r station`. These are: 

2. For each train line, find the station nearest to the CBD. These are: 

3. For each of these stations just before the CBD, calculate the average patronage of train services.

Step 3 is described below, using the example of `r station`.

Service capacity is calculated as the mean number of passsengers on any train stopping at `r station` in two peak travel time periods. The chart below shows:

-   Patronage between 7 and 10am towards Flinders Street, denoted as blue in the charts.

-   Patronage between 4 and 7pm away from Flinders street, shown as green in the charts.

The chart is also split by direction of travel, which in Melbourne's radial network is either towards or away from Flinders street. 

The mean values of these two periods are shown as dashed lines, and the mean of those two numbers is the final score.

```{r warning=FALSE,message=FALSE}
#| echo: false 

to_plot <- hourly_factors %>%
  filter(Station_Name == station) %>%
  filter(Day_Type == 'Normal Weekday') %>%
  mutate(hour_of_day = as.numeric(hour_of_day)) %>%
  group_by(hour_of_day, Direction) %>%
  summarise(avg_patronage = mean(avg_patronage))

morning_to_flinders = to_plot %>%
    filter(Direction == 'Towards Flinders',
           as.numeric(hour_of_day) %in% peak_morning) %>%
    pull(avg_patronage) %>% mean() %>% round(., 2)

evening_away_from_flinders = to_plot %>%
    filter(Direction == 'Away from Flinders',
           as.numeric(hour_of_day) %in% peak_evening) %>%
    pull(avg_patronage) %>% mean() %>% round(., 2)

final_patronage_score = mean(c(morning_to_flinders, evening_away_from_flinders)) %>% round(., 2)

rect_data <- data.frame(
  Direction = c("Towards Flinders", "Away from Flinders"),  # Your actual directions
  xmin = c(7, 16),
  xmax = c(10, 19),
  ymin = -100,
  ymax = 1000,
  fill = c("morning", "evening")
)

mean_data <- data.frame(
  Direction = c("Towards Flinders", "Away from Flinders"),
  y = c(morning_to_flinders, evening_away_from_flinders),
  xmin = c(7, 16),
  xmax = c(10, 19),
  fill = c("morning", "evening")
)

patronage_plot <- ggplot() +
  geom_rect(data = rect_data, 
            mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),  
            alpha = 0.1) + 
  facet_grid(rows = vars(Direction)) +
  geom_segment(data  = mean_data, mapping = aes(x = xmin, xend = xmax, y = y, yend = y, fill = fill), size = 1, linetype = 'dashed', color = 'darkgrey') +
  geom_vline(data = vlines, mapping = aes(xintercept = xintercept), linetype = 'dashed',  color = 'red') +
  geom_point(data = to_plot, mapping = aes(x = hour_of_day, y = avg_patronage, group = 1)) +
  scale_fill_manual(values = c('morning' = 'blue', 'evening' = 'green')) +
  scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
  labs(title = "Average patronage by time of day", fill = " Peak Period") +
  theme_bw(base_size = 13) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab('Hour of day') + 
  ylab('Patronage per train') +
  coord_cartesian(ylim = c(0, max(to_plot$avg_patronage) + 50))

interactive_patronage = ggplotly(patronage_plot, height = 550)
interactive_patronage = layout(interactive_patronage, autosize = T, height = '550', legend = list(orientation = "v",   # horizontal legend
                                         yanchor = "middle",
                                         x = 0.05,
                                         y = 0.85,
                                         bordercolor = "black",    # Border color of the legend
    borderwidth = 1
                                         ))

div(class = 'plot', interactive_patronage)

```

The morning average patronage is `r morning_to_flinders`, the average evening patronage is `r evening_away_from_flinders`, which forms a mean score of `r final_patronage_score`.

## Zoning Suitability

The number of lots within 1km of stations zoned as either Neighbourhood Residential or General Residential, and NOT under heritage protection is an approximation of 'ease of upzoning' for a given station.

The map below shows the properties within 1km of `r station` that meet the conditions above, shaded in orange. Properties that do not meet the conditions described above are black.

Additional information on land use and heritage is provided in tables below the map.

```{r warning=FALSE,message=FALSE}
#| echo: false 


# grz_nrz = near_properties %>%
#     filter(type_short %in% c('Neighbourhood residential', 'General residential')) %>%
#     filter(heritage == F)

grz_nrz = near_properties %>%
  mutate(isNRZGRZ = case_when((zone_short %in% c('Neighbourhood residential', 'General residential', 'Residential growth') & !heritage) ~ T, .default =  F ) ) %>%
  mutate(colour = ifelse(isNRZGRZ, 'orange' ,'black'))

bounds <- c(min(grz_nrz$lon, na.rm = T), min(grz_nrz$lat, na.rm = T),
            max(grz_nrz$lon, na.rm = T), max(grz_nrz$lat, na.rm = T))

#fix panes

leaflet(grz_nrz) %>%
  fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
  setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
  addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
  addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
  addMapPane("labels", zIndex = 430) %>%  
  addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
  addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
  addPolygons(fillColor = ~colour, color = NA, weight = 0, fillOpacity = 0.7, options = pathOptions(pane = "polygons")) %>%
  addLegend(position = 'bottomleft', colors = c('orange','black'), labels = c('Suitable lot for upzoning','Unsuitable lot'), title = "Lot Suitability")
  
n_suitable = grz_nrz %>%
  st_drop_geometry() %>%
  count(isNRZGRZ) %>%
  filter(isNRZGRZ) %>%
  pull(n)

n_unsuitable = grz_nrz %>%
  st_drop_geometry() %>%
  count(isNRZGRZ) %>%
  filter(!isNRZGRZ) %>%
  pull(n)

by_validity <- grz_nrz %>%
  group_by(isNRZGRZ) %>%
  summarise(total_area = sum(st_area(geom))) %>%
  st_drop_geometry()

area_ratio = ( ( by_validity %>% filter(isNRZGRZ) %>% pull(total_area) ) / sum(by_validity$total_area) %>% unname() %>% as.vector() ) %>% round(.,2)

```

:::{.panel-tabset}

## Key information

Out of `r n_suitable + n_unsuitable` lots within 1km radius of `r station`, `r n_suitable` are easiest to upzone. In terms of area, the easiest properties cover `r area_ratio`% of the total area of `r round(sum(by_validity$total_area)/10^6,2)` km^2.

## Tabular data

```{r warning=FALSE,message=FALSE}
#| echo: false 

by_zone_heritage <- near_properties %>%
  st_drop_geometry() %>%
  count(heritage, zone_short) %>%
  dplyr::relocate(zone_short, .before = heritage) %>%
  arrange(zone_short)

# by_zone_heritage %>%
#   mutate(heritage = ifelse(heritage, 'Yes','No')) %>%
#   reactable(
#     theme = sandstone(),
#     pagination = F,
#     columns = list(
#       zone_short = colDef(name = "Zone"),
#       heritage = colDef(name = "Heritage protected"),
#       n = colDef(name = "Number of lots")
#     )
#   )

by_zone_heritage %>%
  group_by(zone_short) %>%
  summarise(n_total = sum(n), percent = n[heritage] / n_total, n_heritage = n[heritage], n_not_heritage = n[!heritage]) %>%
  mutate(percent = round(percent, 2)) %>%
  relocate(n_total, .after = n_not_heritage) %>%
  reactable(
    theme = sandstone(),
    pagination = F,
    columns = list(
      zone_short = colDef(name = "Zone"),
      percent = colDef(name = "% Heritage"),
      n_heritage = colDef(name = "# Heritage Lots"),
      n_not_heritage = colDef(name = "# Non Heritage Lots"),
      n_total = colDef(name = "Total")
    )
  )



```



:::



## Existing Transport Infrastructure

The map below shows tram routes and tram stops in green, as well as bus routes and bus stops in orange.

```{r warning=FALSE,message=FALSE}
#| echo: false 

 
bus_stops = read_sf('../shapefiles/ptv/PTV_METRO_BUS_STOP.shp')
tram_stops = read_sf('../shapefiles/ptv/PTV_METRO_TRAM_STOP.shp')
tram_routes = read_sf('../shapefiles/Order_JRGGG7/ll_gda2020/esrishape/whole_of_dataset/victoria/PTV/PTV_METRO_TRAM_ROUTE.shp')
bus_routes = read_sf('../shapefiles/Order_JRGGG7/ll_gda2020/esrishape/whole_of_dataset/victoria/PTV/PTV_METRO_BUS_ROUTE.SHP')

locations = readRDS(paste0('../r_objects/locations.Rdata'))
  
station_location = locations %>%
    filter(Station_Name == station) %>%
    st_as_sf(coords = c('lng','lat'), crs = 'wgs84')
  
buffer = st_buffer(station_location, dist = radius) %>%
    st_transform(crs = 7844)
  
near_bus_vector <- st_within(bus_stops, buffer, sparse = F)
  
bus_stops_near_station = bus_stops %>%
    filter(near_bus_vector) 

bus_routes_near_station = bus_routes %>%
  filter(ROUTESHTNM %in% bus_stops_near_station$ROUTEUSSP) %>%
  st_intersection(buffer)
  
near_tram_vector <- st_within(tram_stops, buffer, sparse = F)
  
tram_stops_near_station = tram_stops %>%
    filter(near_tram_vector) 

tram_routes_near_station = tram_routes %>%
  filter(ROUTESHTNM %in% tram_stops_near_station$ROUTEUSSP) %>%
  st_intersection(buffer)

tram_route_list <- tram_routes_near_station %>% st_drop_geometry() %>%
  pull(ROUTESHTNM) %>% unique()

bus_route_list <- bus_routes_near_station %>% st_drop_geometry() %>%
  pull(ROUTESHTNM) %>% unique()

leaflet() %>%
  fitBounds(bounds[1], bounds[2], bounds[3], bounds[4]) %>%
  setView(lng = mean(c(bounds[1], bounds[3])), lat = mean(c(bounds[2], bounds[4])), zoom = 14.5) %>%
  addMapPane("background_map", zIndex = 410) %>%  # Level 1: bottom
  addMapPane("polygons", zIndex = 420) %>%        # Level 2: middle
  addMapPane("labels", zIndex = 430) %>%  
  addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_background/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(opacity = 0.7, pane = "background_map")) %>%
    addTiles('https://tiles.stadiamaps.com/tiles/stamen_toner_labels/{z}/{x}/{y}.png?api_key=090a847c-32a2-4e35-99a9-543ad8f4ecc8', options = tileOptions(pane = "labels")) %>%
  addCircleMarkers(data = tram_stops_near_station, color = "black", radius = 3, fillColor = "#78BE20", fillOpacity = 1, options = pathOptions(pane = 'polygons'), stroke = 0.5, weight = 1, opacity = 1) %>%
  addCircleMarkers(data = bus_stops_near_station, fillOpacity = 1, radius = 3, fillColor = "#FF8200", color = "black", stroke = 0.5, options = pathOptions(pane = 'polygons'), weight = 1, opacity = 1) %>%
  addPolylines(data = bus_routes_near_station, color = "#FF8200", options = pathOptions(pane = 'polygons'), fillOpacity = 0.7) %>%
  addPolylines(data = tram_routes_near_station, color = "#78BE20", options = pathOptions(pane = 'polygons'), fillOpacity = 0.7) %>%
  addPolygons(data = buffer, color = 'black', fillColor = 'grey', fillOpacity = 0.3, options = pathOptions(pane = 'polygons'))

```

There are `r tram_stops_near_station %>% nrow()` tram stops in a 1km radius, and `r bus_stops_near_station %>% nrow()` bus stops. In the model, tram stops are weighted to be worth twice as much as bus stops, as trams carry more passengers and are often more frequent.

This yields a total score of `r 2*(tram_stops_near_station %>% nrow()) + (bus_stops_near_station %>% nrow())`.

The model does not factor in characteristics of individual bus and tram routes, such as frequency and available capacity due to unavailable data. However, for information's sake, bus route(s) `r bus_route_list` and tram route(s) `r tram_route_list` serve this area.

## Capacity Delta

Zoned capacity is a measure of how many dwellings could fit in an area, given the current zoning. It is a theoretic maximum. This section looks at the current zoned capacity, and compares it to a theoretic zoned capacity under 'Missing Middle' zoning. To reiterate, the potential future zoned capacity is **a theoretic maximum**, and extremely unlikely to be realised if upzoning occured.

```{r warning=FALSE,message=FALSE}
#| echo: false 

delta = near_properties %>%
  st_drop_geometry() %>%
  group_by(zone_short) %>%
  summarise(old_yield = sum(buxton_yeilds_corrected_net, na.rm = T), new_yield = sum(mm_yield_net, na.rm = T))

delta %>% reactable(theme = sandstone(),
                    columns = list(
                      zone_short = colDef(name = "Current Zone"),
                      old_yield = colDef(name = "Existing Zoned Capacity"),
                      new_yield = colDef(name = "Potential Future Zoned Capacity")
                    )) 

```
