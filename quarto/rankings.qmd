---
title: "Full Station Rankings"
author: "Paul S"
date: "6/6/24"
params: 
  station: "Brunswick"
format: 
  html: 
    theme: zephyr
    fig-width: 8
    fig-height: 8
    code-fold: false
    toc: true
    toc-depth: 4
    toc-location: left
    page-layout: full
---

```{r}

station = params$station

library(tidyverse)
library(reactablefmtr)

source('../r/station_functions.R')
source('../r/constants.R')
source('../r/transform.R')
```

# Full Methodology

This page aims to describe how each metric is calculated and why it is important to consider. Each metric is stepped through in no particular order before an explanation of the mechanism used to transform and rank the scores is provided.

-   Zoning suitability
-   Potential number of new homes
-   Train service frequency in peak
-   Train service passenger numbers in peak
-   Number of local services within a 500m walk
-   Distance to CBD
-   Existing transport infrastructure.

Metrics were chosen based on two factors

-   data being available to support the analysis
-   data is able to be manipulated into a single number

The rankings are intended to capture which stations should be upzoned as a priority **right now** without having to amend any legislation, alter zoning, change public transport service frequencies or build new infrastructure. Hence, some metrics are a representation of the day they were calculated and are likely to change over time, requiring the model to be re-run when new data is available.

callout box: for example the metro tunnel throws all this out.

## Service Frequency

## Number of Local Services

## Distance to CBD

## Existing Transport Infrastructure

## Zoning suitability

This measure intends to capture the suitability of existing zoning surrounding train stations.

An ideal station would have many low density residential lots that are able to be redeveloped and not subject to external heritage controls.

Therefore, a 'suitable lot' is defined as:

-   Either Neighbourhood Residential or General Residential

-   Not under any heritage control

The measure is calculated as the area of suitable properties in square metres, divided by the total area of all properties within a suitable radius. Train stations that score poorly in this metric are likely to either be mostly non-residential already, or be subject to extreme heritage controls, which meets the intention for this metric.

## Zoned Capacity

Zoned capacity is a measure of how many dwellings could fit in an area, given the current zoning. It is a theoretic maximum. This section looks at the current zoned capacity, and compares it to a theoretic zoned capacity under 'Missing Middle' zoning. To reiterate, the potential future zoned capacity is **a theoretic maximum**, and extremely unlikely to be realised if upzoning occured.

## Line Capacity

```{r}

station_lines = readRDS('../r_objects/stations_with_lines.Rdata') %>%
  filter(Station_Name == station) %>%
  pull(lines) %>%
  unlist() %>%
  as.vector()

station_targets = readRDS('../r_objects/target_stations.Rdata') %>% 
  filter(Station_Name == station) %>%
  pull(targets) %>%
  unlist() %>%
  as.vector() %>%
  first()

```

This metric aims to measure the amount of space available on trains passing through this station, as there is little point upzoning if there is no capacity to move people.

However, for stations in the middle of a train line, passengers will typically continue to board the train until the city. This means that it is not useful to only look at the patronage as trains pass through a given station as more passengers may board later.

Instead, it is best to look at the average number of passengers on trains at their last station before the CBD. This gives a better measure of how busy the line itself is overall.

##### Process for `r station`

1.  Find the train line(s) that serve `r station`: `r station_lines`

2.  For each train line, find the station nearest to the CBD. These are by definition the same for each line: `r station_targets`.

3.  For each of these stations just before the CBD, calculate the average patronage of train services at that station, but restrict the search to only train services on the lines identified in step 1.

## Raw Scores

```{r warning=FALSE,message=FALSE}
#| echo: false 




station_rankings = readRDS('../r_objects/station_rankings.Rdata') %>%
  mutate(across(-station, as.numeric)) %>%
  mutate(across(where(is.numeric), .fns = function(x) {round(x,2)}))

station_rankings %>%
  reactable( pagination = T,
    theme = sandstone(), searchable = T)

```

## How does the transformation work?

Each raw score is in different units, so the first task is to transform all the metrics into something that can be summed into one total score.

This is achieved by scaling each column (of all the scores) so that each value is relative to the maximum and minimum values from other stations, also known as xmin-xmax scaling. The end result is a value between zero and 1 across all metrics, allowing an easy summation.

$$
x = \frac{x - \min{x} }{ \max{x} - \min{x} }
$$

The problem is that some metrics are beneficial, e.g. NRZ/GRZ Percentage. However, some metrics are detrimental, e.g. distance.

To deal with this problem, weights are applied to each metric, with negative weights representing unwanted metrics.

By default, weights are set as:

```{r warning=FALSE,message=FALSE}
#| echo: false 

weights_df <- weights %>%
  as.data.frame() 

weights_df = weights_df %>%
  mutate(var = rownames(weights_df))
  
colnames(weights_df) = c('weight' , 'variable')

weights_df = weights_df %>%
  pivot_wider(names_from = variable, values_from = weight)

rownames(weights_df) = "Weight"

weights_df %>%
  reactable(rownames = T, theme = sandstone())

```

These transformed scores are then summed to produce a final score.

::: callout-note
There are some restrictions placed on final rankings:

-   City loop stations are excluded as they can't be upzoned further.

-   Stations further than 25km of Flinders Street are excluded as they are generally economically unfeasible to upzone.

This restriction is arbitrary and will be improved alongside the model.
:::

<!-- ## Example Transformation -->

```{r warning=FALSE,message=FALSE}
#| echo: false 

# example_rankings = readRDS('../r_objects/station_rankings.Rdata') %>%
#   filter(station %in% c('Brunswick', 'Merri', 'Carnegie')) %>%
#   mutate(across(-station, as.numeric)) %>%
#   mutate(across(where(is.numeric), .fns = function(x) {round(x,2)}))

#example_rankings %>% reactable()

#example_transformed = transform_scores_xminxmax(example_rankings)

#example_transformed %>% reactable()


```

## Transformed Scores

```{r warning=FALSE,message=FALSE}
#| echo: false 

transformed_scores = readRDS('../r_objects/transformed_scores.Rdata') %>%
  mutate(across(-station, as.numeric)) %>%
  mutate(across(where(is.numeric), .fns = function(x) {round(x,2)}))

transformed_scores %>%
  reactable( theme = sandstone(),
             searchable = T,
             defaultSorted = 'score',
             defaultSortOrder = 'desc',
             columns = list(
             ) )

```
